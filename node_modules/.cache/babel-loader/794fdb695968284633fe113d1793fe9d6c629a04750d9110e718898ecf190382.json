{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? dom.body.childNodes : [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;","map":{"version":3,"names":["selection","require","lexical","$generateNodesFromDOM","editor","dom","lexicalNodes","elements","body","childNodes","i","length","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$generateHtmlFromNodes","document","window","Error","container","createElement","root","$getRoot","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","selection$1","shouldInclude","isSelected","shouldExclude","$isElementNode","excludeFromCopy","target","clone","$cloneWithProperties","$isTextNode","$sliceSelectedTextNodeContent","children","after","exportDOM","fragment","createDocumentFragment","childNode","shouldIncludeChild","extractWithChild","append","newElement","call","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","get","toLowerCase","currentConversion","undefined","cachedConversion","domConversion","priority","conversion","Set","node","forChildMap","Map","parentLexicalNode","preformatted","currentLexicalNode","transformFunction","transformOutput","postTransform","forChildFunction","push","forChild","set","childLexicalNodes","exports"],"sources":["D:/polleditor-server/poll-editor/node_modules/@lexical/html/LexicalHtml.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? dom.body.childNodes : [];\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = document.createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}