{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport axios from 'axios';\n\n// Async thunks for API calls\nexport const fetchPolls = createAsyncThunk('polls/fetchPolls', async () => {\n  const response = await axios.get('/api/polls');\n  return response.data;\n});\nexport const createPoll = createAsyncThunk('polls/createPoll', async pollData => {\n  const response = await axios.post('/api/polls', pollData);\n  return response.data;\n});\nexport const updatePoll = createAsyncThunk('polls/updatePoll', async ({\n  id,\n  pollData\n}) => {\n  const response = await axios.put(`/api/polls/${id}`, pollData);\n  return response.data;\n});\n\n/**\r\n * votePoll thunk supports modes:\r\n * - { mode: 'vote' } -> POST /api/polls/:pollId/vote { optionId }\r\n * - { mode: 'undo' } -> DELETE /api/polls/:pollId/vote { optionId } (sent as request body)\r\n * - { mode: 'switch' } -> POST /api/polls/:pollId/switch { fromOptionId, toOptionId }\r\n *\r\n * The thunk returns the updated poll object from the server.\r\n */\nexport const votePoll = createAsyncThunk('polls/votePoll', async ({\n  pollId,\n  optionId,\n  mode = 'vote',\n  fromOptionId = null\n}) => {\n  if (mode === 'undo') {\n    // axios.delete with body: axios accepts { data: {...} } as second arg\n    const response = await axios.delete(`/api/polls/${pollId}/vote`, {\n      data: {\n        optionId\n      }\n    });\n    return response.data;\n  }\n  if (mode === 'switch') {\n    // try a dedicated switch endpoint first; fallback to undo+vote if needed\n    try {\n      const response = await axios.post(`/api/polls/${pollId}/switch`, {\n        fromOptionId,\n        toOptionId: optionId\n      });\n      return response.data;\n    } catch (err) {\n      // fallback: attempt undo then vote sequentially\n      // NOTE: backend should ideally provide a switch endpoint for atomicity\n      await axios.delete(`/api/polls/${pollId}/vote`, {\n        data: {\n          optionId: fromOptionId\n        }\n      });\n      const response = await axios.post(`/api/polls/${pollId}/vote`, {\n        optionId\n      });\n      return response.data;\n    }\n  }\n\n  // default: a new vote\n  const response = await axios.post(`/api/polls/${pollId}/vote`, {\n    optionId\n  });\n  return response.data;\n});\nexport const deletePoll = createAsyncThunk('polls/deletePoll', async pollId => {\n  const response = await axios.delete(`/api/polls/${pollId}`);\n  return {\n    pollId,\n    ...response.data\n  };\n});\nexport const resetPoll = createAsyncThunk('polls/resetPoll', async pollId => {\n  const response = await axios.post(`/api/polls/${pollId}/reset`);\n  return response.data;\n});\nconst pollsSlice = createSlice({\n  name: 'polls',\n  initialState: {\n    polls: [],\n    currentPoll: null,\n    loading: false,\n    error: null\n  },\n  reducers: {\n    setCurrentPoll: (state, action) => {\n      state.currentPoll = action.payload;\n    },\n    updatePollInStore: (state, action) => {\n      const index = state.polls.findIndex(poll => poll._id === action.payload._id);\n      if (index !== -1) {\n        state.polls[index] = action.payload;\n      }\n      if (state.currentPoll && state.currentPoll._id === action.payload._id) {\n        state.currentPoll = action.payload;\n      }\n    },\n    addPollToStore: (state, action) => {\n      state.polls.unshift(action.payload);\n    },\n    removePollFromStore: (state, action) => {\n      const pollId = action.payload;\n      state.polls = state.polls.filter(p => p._id !== pollId);\n      if (state.currentPoll && state.currentPoll._id === pollId) {\n        state.currentPoll = null;\n      }\n    },\n    // Optimistic vote update (increment a local copy until server confirms)\n    incrementVoteOptimistic: (state, action) => {\n      const {\n        pollId,\n        optionId\n      } = action.payload;\n      const poll = state.polls.find(p => p._id === pollId);\n      if (!poll) return;\n      const option = poll.options.find(o => o._id === optionId);\n      if (!option) return;\n      option.votes = (option.votes || 0) + 1;\n      poll.totalVotes = (poll.totalVotes || 0) + 1;\n      if (state.currentPoll && state.currentPoll._id === pollId) {\n        state.currentPoll = {\n          ...poll\n        };\n      }\n    },\n    // Optimistic undo (decrement)\n    decrementVoteOptimistic: (state, action) => {\n      const {\n        pollId,\n        optionId\n      } = action.payload;\n      const poll = state.polls.find(p => p._id === pollId);\n      if (!poll) return;\n      const option = poll.options.find(o => o._id === optionId);\n      if (!option) return;\n      option.votes = Math.max(0, (option.votes || 0) - 1);\n      poll.totalVotes = Math.max(0, (poll.totalVotes || 0) - 1);\n      if (state.currentPoll && state.currentPoll._id === pollId) {\n        state.currentPoll = {\n          ...poll\n        };\n      }\n    },\n    // Optimistic switch: decrement fromOption, increment toOption (totalVotes stays same)\n    switchVoteOptimistic: (state, action) => {\n      const {\n        pollId,\n        fromOptionId,\n        toOptionId\n      } = action.payload;\n      const poll = state.polls.find(p => p._id === pollId);\n      if (!poll) return;\n      const fromOpt = poll.options.find(o => o._id === fromOptionId);\n      const toOpt = poll.options.find(o => o._id === toOptionId);\n      if (fromOpt) {\n        fromOpt.votes = Math.max(0, (fromOpt.votes || 0) - 1);\n      }\n      if (toOpt) {\n        toOpt.votes = (toOpt.votes || 0) + 1;\n      }\n      // totalVotes unchanged for a switch\n      if (state.currentPoll && state.currentPoll._id === pollId) {\n        state.currentPoll = {\n          ...poll\n        };\n      }\n    }\n  },\n  extraReducers: builder => {\n    builder\n    // Fetch polls\n    .addCase(fetchPolls.pending, state => {\n      state.loading = true;\n    }).addCase(fetchPolls.fulfilled, (state, action) => {\n      state.loading = false;\n      state.polls = action.payload;\n      state.error = null;\n    }).addCase(fetchPolls.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.error.message;\n    })\n    // Create poll\n    .addCase(createPoll.fulfilled, (state, action) => {\n      state.polls.unshift(action.payload);\n    })\n    // Update poll\n    .addCase(updatePoll.fulfilled, (state, action) => {\n      const index = state.polls.findIndex(poll => poll._id === action.payload._id);\n      if (index !== -1) {\n        state.polls[index] = action.payload;\n      }\n      if (state.currentPoll && state.currentPoll._id === action.payload._id) {\n        state.currentPoll = action.payload;\n      }\n    })\n    // Vote poll (server confirmation)\n    .addCase(votePoll.fulfilled, (state, action) => {\n      // server returns the updated poll; replace in store\n      const updatedPoll = action.payload;\n      const index = state.polls.findIndex(poll => poll._id === updatedPoll._id);\n      if (index !== -1) {\n        state.polls[index] = updatedPoll;\n      } else {\n        // if not present, add it\n        state.polls.unshift(updatedPoll);\n      }\n      if (state.currentPoll && state.currentPoll._id === updatedPoll._id) {\n        state.currentPoll = updatedPoll;\n      }\n    })\n    // Delete poll\n    .addCase(deletePoll.fulfilled, (state, action) => {\n      const pollId = action.payload.pollId;\n      state.polls = state.polls.filter(p => p._id !== pollId);\n      if (state.currentPoll && state.currentPoll._id === pollId) {\n        state.currentPoll = null;\n      }\n    })\n    // Reset poll\n    .addCase(resetPoll.fulfilled, (state, action) => {\n      const index = state.polls.findIndex(p => p._id === action.payload._id);\n      if (index !== -1) {\n        state.polls[index] = action.payload;\n      }\n      if (state.currentPoll && state.currentPoll._id === action.payload._id) {\n        state.currentPoll = action.payload;\n      }\n    });\n  }\n});\nexport const {\n  setCurrentPoll,\n  updatePollInStore,\n  addPollToStore,\n  removePollFromStore,\n  incrementVoteOptimistic,\n  decrementVoteOptimistic,\n  switchVoteOptimistic\n} = pollsSlice.actions;\nexport default pollsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","axios","fetchPolls","response","get","data","createPoll","pollData","post","updatePoll","id","put","votePoll","pollId","optionId","mode","fromOptionId","delete","toOptionId","err","deletePoll","resetPoll","pollsSlice","name","initialState","polls","currentPoll","loading","error","reducers","setCurrentPoll","state","action","payload","updatePollInStore","index","findIndex","poll","_id","addPollToStore","unshift","removePollFromStore","filter","p","incrementVoteOptimistic","find","option","options","o","votes","totalVotes","decrementVoteOptimistic","Math","max","switchVoteOptimistic","fromOpt","toOpt","extraReducers","builder","addCase","pending","fulfilled","rejected","message","updatedPoll","actions","reducer"],"sources":["D:/server/poll-editor/src/redux/pollsSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\r\nimport axios from 'axios';\r\n\r\n// Async thunks for API calls\r\nexport const fetchPolls = createAsyncThunk(\r\n  'polls/fetchPolls',\r\n  async () => {\r\n    const response = await axios.get('/api/polls');\r\n    return response.data;\r\n  }\r\n);\r\n\r\nexport const createPoll = createAsyncThunk(\r\n  'polls/createPoll',\r\n  async (pollData) => {\r\n    const response = await axios.post('/api/polls', pollData);\r\n    return response.data;\r\n  }\r\n);\r\n\r\nexport const updatePoll = createAsyncThunk(\r\n  'polls/updatePoll',\r\n  async ({ id, pollData }) => {\r\n    const response = await axios.put(`/api/polls/${id}`, pollData);\r\n    return response.data;\r\n  }\r\n);\r\n\r\n/**\r\n * votePoll thunk supports modes:\r\n * - { mode: 'vote' } -> POST /api/polls/:pollId/vote { optionId }\r\n * - { mode: 'undo' } -> DELETE /api/polls/:pollId/vote { optionId } (sent as request body)\r\n * - { mode: 'switch' } -> POST /api/polls/:pollId/switch { fromOptionId, toOptionId }\r\n *\r\n * The thunk returns the updated poll object from the server.\r\n */\r\nexport const votePoll = createAsyncThunk(\r\n  'polls/votePoll',\r\n  async ({ pollId, optionId, mode = 'vote', fromOptionId = null }) => {\r\n    if (mode === 'undo') {\r\n      // axios.delete with body: axios accepts { data: {...} } as second arg\r\n      const response = await axios.delete(`/api/polls/${pollId}/vote`, { data: { optionId } });\r\n      return response.data;\r\n    }\r\n\r\n    if (mode === 'switch') {\r\n      // try a dedicated switch endpoint first; fallback to undo+vote if needed\r\n      try {\r\n        const response = await axios.post(`/api/polls/${pollId}/switch`, {\r\n          fromOptionId,\r\n          toOptionId: optionId,\r\n        });\r\n        return response.data;\r\n      } catch (err) {\r\n        // fallback: attempt undo then vote sequentially\r\n        // NOTE: backend should ideally provide a switch endpoint for atomicity\r\n        await axios.delete(`/api/polls/${pollId}/vote`, { data: { optionId: fromOptionId } });\r\n        const response = await axios.post(`/api/polls/${pollId}/vote`, { optionId });\r\n        return response.data;\r\n      }\r\n    }\r\n\r\n    // default: a new vote\r\n    const response = await axios.post(`/api/polls/${pollId}/vote`, { optionId });\r\n    return response.data;\r\n  }\r\n);\r\n\r\nexport const deletePoll = createAsyncThunk(\r\n  'polls/deletePoll',\r\n  async (pollId) => {\r\n    const response = await axios.delete(`/api/polls/${pollId}`);\r\n    return { pollId, ...response.data };\r\n  }\r\n);\r\n\r\nexport const resetPoll = createAsyncThunk(\r\n  'polls/resetPoll',\r\n  async (pollId) => {\r\n    const response = await axios.post(`/api/polls/${pollId}/reset`);\r\n    return response.data;\r\n  }\r\n);\r\n\r\nconst pollsSlice = createSlice({\r\n  name: 'polls',\r\n  initialState: {\r\n    polls: [],\r\n    currentPoll: null,\r\n    loading: false,\r\n    error: null,\r\n  },\r\n  reducers: {\r\n    setCurrentPoll: (state, action) => {\r\n      state.currentPoll = action.payload;\r\n    },\r\n    updatePollInStore: (state, action) => {\r\n      const index = state.polls.findIndex(poll => poll._id === action.payload._id);\r\n      if (index !== -1) {\r\n        state.polls[index] = action.payload;\r\n      }\r\n      if (state.currentPoll && state.currentPoll._id === action.payload._id) {\r\n        state.currentPoll = action.payload;\r\n      }\r\n    },\r\n    addPollToStore: (state, action) => {\r\n      state.polls.unshift(action.payload);\r\n    },\r\n    removePollFromStore: (state, action) => {\r\n      const pollId = action.payload;\r\n      state.polls = state.polls.filter(p => p._id !== pollId);\r\n      if (state.currentPoll && state.currentPoll._id === pollId) {\r\n        state.currentPoll = null;\r\n      }\r\n    },\r\n\r\n    // Optimistic vote update (increment a local copy until server confirms)\r\n    incrementVoteOptimistic: (state, action) => {\r\n      const { pollId, optionId } = action.payload;\r\n      const poll = state.polls.find(p => p._id === pollId);\r\n      if (!poll) return;\r\n      const option = poll.options.find(o => o._id === optionId);\r\n      if (!option) return;\r\n      option.votes = (option.votes || 0) + 1;\r\n      poll.totalVotes = (poll.totalVotes || 0) + 1;\r\n      if (state.currentPoll && state.currentPoll._id === pollId) {\r\n        state.currentPoll = { ...poll };\r\n      }\r\n    },\r\n\r\n    // Optimistic undo (decrement)\r\n    decrementVoteOptimistic: (state, action) => {\r\n      const { pollId, optionId } = action.payload;\r\n      const poll = state.polls.find(p => p._id === pollId);\r\n      if (!poll) return;\r\n      const option = poll.options.find(o => o._id === optionId);\r\n      if (!option) return;\r\n      option.votes = Math.max(0, (option.votes || 0) - 1);\r\n      poll.totalVotes = Math.max(0, (poll.totalVotes || 0) - 1);\r\n      if (state.currentPoll && state.currentPoll._id === pollId) {\r\n        state.currentPoll = { ...poll };\r\n      }\r\n    },\r\n\r\n    // Optimistic switch: decrement fromOption, increment toOption (totalVotes stays same)\r\n    switchVoteOptimistic: (state, action) => {\r\n      const { pollId, fromOptionId, toOptionId } = action.payload;\r\n      const poll = state.polls.find(p => p._id === pollId);\r\n      if (!poll) return;\r\n      const fromOpt = poll.options.find(o => o._id === fromOptionId);\r\n      const toOpt = poll.options.find(o => o._id === toOptionId);\r\n      if (fromOpt) {\r\n        fromOpt.votes = Math.max(0, (fromOpt.votes || 0) - 1);\r\n      }\r\n      if (toOpt) {\r\n        toOpt.votes = (toOpt.votes || 0) + 1;\r\n      }\r\n      // totalVotes unchanged for a switch\r\n      if (state.currentPoll && state.currentPoll._id === pollId) {\r\n        state.currentPoll = { ...poll };\r\n      }\r\n    },\r\n  },\r\n  extraReducers: (builder) => {\r\n    builder\r\n      // Fetch polls\r\n      .addCase(fetchPolls.pending, (state) => {\r\n        state.loading = true;\r\n      })\r\n      .addCase(fetchPolls.fulfilled, (state, action) => {\r\n        state.loading = false;\r\n        state.polls = action.payload;\r\n        state.error = null;\r\n      })\r\n      .addCase(fetchPolls.rejected, (state, action) => {\r\n        state.loading = false;\r\n        state.error = action.error.message;\r\n      })\r\n      // Create poll\r\n      .addCase(createPoll.fulfilled, (state, action) => {\r\n        state.polls.unshift(action.payload);\r\n      })\r\n      // Update poll\r\n      .addCase(updatePoll.fulfilled, (state, action) => {\r\n        const index = state.polls.findIndex(poll => poll._id === action.payload._id);\r\n        if (index !== -1) {\r\n          state.polls[index] = action.payload;\r\n        }\r\n        if (state.currentPoll && state.currentPoll._id === action.payload._id) {\r\n          state.currentPoll = action.payload;\r\n        }\r\n      })\r\n      // Vote poll (server confirmation)\r\n      .addCase(votePoll.fulfilled, (state, action) => {\r\n        // server returns the updated poll; replace in store\r\n        const updatedPoll = action.payload;\r\n        const index = state.polls.findIndex(poll => poll._id === updatedPoll._id);\r\n        if (index !== -1) {\r\n          state.polls[index] = updatedPoll;\r\n        } else {\r\n          // if not present, add it\r\n          state.polls.unshift(updatedPoll);\r\n        }\r\n        if (state.currentPoll && state.currentPoll._id === updatedPoll._id) {\r\n          state.currentPoll = updatedPoll;\r\n        }\r\n      })\r\n      // Delete poll\r\n      .addCase(deletePoll.fulfilled, (state, action) => {\r\n        const pollId = action.payload.pollId;\r\n        state.polls = state.polls.filter(p => p._id !== pollId);\r\n        if (state.currentPoll && state.currentPoll._id === pollId) {\r\n          state.currentPoll = null;\r\n        }\r\n      })\r\n      // Reset poll\r\n      .addCase(resetPoll.fulfilled, (state, action) => {\r\n        const index = state.polls.findIndex(p => p._id === action.payload._id);\r\n        if (index !== -1) {\r\n          state.polls[index] = action.payload;\r\n        }\r\n        if (state.currentPoll && state.currentPoll._id === action.payload._id) {\r\n          state.currentPoll = action.payload;\r\n        }\r\n      });\r\n  },\r\n});\r\n\r\nexport const {\r\n  setCurrentPoll,\r\n  updatePollInStore,\r\n  addPollToStore,\r\n  removePollFromStore,\r\n  incrementVoteOptimistic,\r\n  decrementVoteOptimistic,\r\n  switchVoteOptimistic,\r\n} = pollsSlice.actions;\r\n\r\nexport default pollsSlice.reducer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}