{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\n\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\n\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\n\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\n\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\n\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n  const siblings = listItem.getPreviousSiblings();\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n  return value;\n}\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      } else {\n        const handled = new Set();\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n            while (parent != null) {\n              const parentKey = parent.getKey();\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n                break;\n              } else {\n                const nextParent = parent.getParent();\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\n\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n    updateChildrenListItemValue(list1);\n  }\n  list2.remove();\n}\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. If only certain children should be updated, they\n * can be passed optionally in an array.\n * @param list - The list whose children are updated.\n * @param children - An array of the children to be updated.\n */\n\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\n\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n      updateChildrenListItemValue(newList);\n    }\n  }\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\n\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      } // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n      grandparentListItem.replace(listItemNode);\n    }\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\n\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) return replaceWithNode;\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    const siblings = this.getNextSiblings();\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    } else if (nextSibling) {\n      const parent = nextSibling.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n    return super.insertBefore(nodeToInsert);\n  }\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\n\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\n\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  } // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    updateChildrenListItemValue(this);\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\n\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\n\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;","map":{"version":3,"names":["lexical","require","utils","$getListDepth","listNode","depth","parent","getParent","$isListItemNode","parentList","$isListNode","Error","$getTopListNode","listItem","list","$getAllListItems","node","listItemNodes","listChildren","getChildren","filter","i","length","listItemNode","firstChild","getFirstChild","concat","push","isNestedListNode","$removeHighestEmptyListParent","sublist","emptyListPtr","getNextSibling","getPreviousSibling","remove","wrapInListItem","listItemWrapper","$createListItemNode","append","$isSelectingEmptyListItem","anchorNode","nodes","is","getChildrenSize","$getListItemValue","value","getStart","siblings","getPreviousSiblings","sibling","insertList","editor","listType","update","selection","$getSelection","$isRangeSelection","DEPRECATED_$isGridSelection","getNodes","anchor","getNode","anchorNodeParent","$createListNode","$isRootOrShadowRoot","replace","$isElementNode","setFormat","getFormatType","setIndent","getIndent","getParentOrThrow","handled","Set","isEmpty","has","getKey","createListOrMerge","$isLeafNode","parentKey","newListNode","updateChildrenListItemValue","add","nextParent","nodesToAppend","splice","previousSibling","nextSibling","getListType","getFirstChildOrThrow","insertBefore","mergeLists","list1","list2","listItem1","getLastChild","listItem2","toMerge","removeList","listNodes","$getNearestNodeOfType","ListItemNode","insertionPoint","listItems","paragraph","$createParagraphNode","insertAfter","__key","key","set","focus","children","childrenOrExisting","undefined","child","prevValue","getValue","nextValue","setValue","$handleIndent","removed","innerList","nextInnerList","newListItem","newList","$handleOutdent","grandparentListItem","greatGrandparentList","lastChild","previousSiblingsListItem","previousSiblingsList","forEach","nextSiblingsListItem","nextSiblingsList","getNextSiblings","$handleListInsertParagraph","isCollapsed","getTextContent","topListNode","grandparent","replacementNode","select","nextSiblings","$isParagraphNode","ElementNode","getType","clone","__value","__checked","constructor","checked","createDOM","config","element","document","createElement","updateListItemChecked","$setListItemThemeClassNames","theme","updateDOM","prevNode","dom","transform","getChecked","setChecked","importDOM","li","conversion","convertListItemElement","priority","importJSON","serializedNode","format","setDirection","direction","exportJSON","type","version","canMergeWith","replaceWithNode","includeChildren","__first","__last","nodeToAppend","restoreSelection","after","afterListNode","preserveEmptyParent","prevSibling","insertNewAfter","_","newElement","collapseAtStart","listNodeParent","isIndented","offset","self","getLatest","getWritable","toggleChecked","__indent","indentLevel","indent","currentIndent","nodeToInsert","canInsertAfter","canReplaceWith","replacement","extractWithChild","focusNode","isParentOf","isParentRequired","createParentElementNode","editorThemeClasses","classesToAdd","classesToRemove","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","listItemClasses","split","parentNode","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","some","removeClassNamesFromElement","addClassNamesToElement","prevListItemNode","removeAttribute","setAttribute","domNode","isHTMLElement","getAttribute","$applyNodeReplacement","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","start","_listType","getTag","_editor","tag","String","__lexicalListType","setListThemeClassNames","ol","convertListNode","ul","exportDOM","canBeEmpty","canIndent","currentNode","textNode","$createTextNode","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","normalizeChildren","normalizedListItems","nodeName","toLowerCase","INSERT_UNORDERED_LIST_COMMAND","createCommand","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND","exports"],"sources":["D:/server/poll-editor/node_modules/@lexical/list/LexicalList.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\n\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\n\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\n\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\n\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\n\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\n\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\n\n\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n\n  const toMerge = list2.getChildren();\n\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n    updateChildrenListItemValue(list1);\n  }\n\n  list2.remove();\n}\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n\n        listNode.remove();\n      }\n    }\n  });\n}\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. If only certain children should be updated, they\n * can be passed optionally in an array.\n * @param list - The list whose children are updated.\n * @param children - An array of the children to be updated.\n */\n\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\n\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n\n  const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n\n      updateChildrenListItemValue(newList);\n    }\n  }\n\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\n\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      } // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n      grandparentListItem.replace(listItemNode);\n    }\n\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\n\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static transform() {\n    return node => {\n      const parent = node.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) return replaceWithNode;\n\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n\n    this.remove();\n\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node, restoreSelection);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    } else if (nextSibling) {\n      const parent = nextSibling.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\n\n\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\n\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType, start, key) {\n    super(key);\n\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  getListType() {\n    return this.__listType;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    updateChildrenListItemValue(this);\n    return this;\n  }\n\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n\n  return normalizedListItems;\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\n\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\n\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\n\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}