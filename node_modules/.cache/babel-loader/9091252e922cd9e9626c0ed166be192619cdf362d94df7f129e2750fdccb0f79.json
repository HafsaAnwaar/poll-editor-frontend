{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = React.useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState\n    } = initialConfig;\n    const context = LexicalComposerContext.createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n    if (editor === null) {\n      const newEditor = lexical.createEditor({\n        editable: initialConfig.editable,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffect(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n      if (root.isEmpty()) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = lexical.$getRoot();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\nexports.LexicalComposer = LexicalComposer;","map":{"version":3,"names":["LexicalComposerContext","require","lexical","React","CAN_USE_DOM","window","document","createElement","useLayoutEffectImpl","useLayoutEffect","useEffect","HISTORY_MERGE_OPTIONS","tag","LexicalComposer","initialConfig","children","composerContext","useMemo","theme","namespace","editor__DEPRECATED","initialEditor","nodes","onError","editorState","initialEditorState","context","createLexicalComposerContext","editor","newEditor","createEditor","editable","error","initializeEditor","isEditable","setEditable","undefined","Provider","value","update","root","$getRoot","isEmpty","paragraph","$createParagraphNode","append","activeElement","$getSelection","getRootElement","select","parsedEditorState","parseEditorState","setEditorState","exports"],"sources":["D:/polleditor-server/polleditor-server/poll-editor/node_modules/@lexical/react/LexicalComposer.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = React.useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState\n    } = initialConfig;\n    const context = LexicalComposerContext.createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n\n    if (editor === null) {\n      const newEditor = lexical.createEditor({\n        editable: initialConfig.editable,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n\n    return [editor, context];\n  }, // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffect(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\n\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n\n      if (root.isEmpty()) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'function':\n        {\n          editor.update(() => {\n            const root = lexical.$getRoot();\n\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexports.LexicalComposer = LexicalComposer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}